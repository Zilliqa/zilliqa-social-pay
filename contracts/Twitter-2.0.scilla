scilla_version 0

import BoolUtils IntUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library SocialPay

let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
      Cons {Message} msg nil_msg

(* Custom ADT storing twitter_id, recipient_address, tweet_id, hashtags *)
type VerifyInfo =
| VerifyInfo of String ByStr20 String (List String)

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotAdmin
  | CodeTweetAlreadyExists
  | CodeTweetNotValid
  | CodeTweetWithinDay

let make_error_event =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotOwner           => Int32 -1
      | CodeNotAdmin           => Int32 -2
      | CodeTweetAlreadyExists => Int32 -3
      | CodeTweetNotValid      => Int32 -4
      | CodeTweetWithinDay     => Int32 -5
      end
    in
    { _eventname : "Error"; code : result_code }

let tt = True
let ff = False

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SocialPay
(
  owner: ByStr20,
  hashtag: String,
  zils_per_tweet : Uint128,
  blocks_per_day : Uint32
)

(* Map of tweet_id to twitter_id *)
field verified_tweets: Map String String = Emp String String

(* Map of twitter_id to last claim block number *)
field last_claims: Map String BNum = Emp String BNum

(* Map of address to bool status of admin *)
field admins: Map ByStr20 Bool = Emp ByStr20 Bool

field verdad: Bool = False

procedure EmitError(err: Error)
  e = make_error_event err;
  event e
end

procedure IsOwner()
  is_owner = builtin eq owner _sender;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotOwner;
    EmitError err
  end
end

procedure IsAdmin()
  is_admin <- exists admins[_sender];
  match is_admin with
  | True =>
  | False =>
    err = CodeNotAdmin;
    EmitError err
  end
end

procedure ConfigureAdmin(admin_address: ByStr20)
  is_admin <- exists admins[admin_address];
  match is_admin with
  | True =>
    delete admins[admin_address];
    e = {_eventname : "DeletedAdmin"; admin_address: admin_address};
    event e
  | False =>
    admins[admin_address] := tt;
    e = {_eventname : "AddedAdmin"; admin_address: admin_address};
    event e
  end
end

procedure ValidateTweet(input_hashtag: String)
  is_hashtag = builtin eq input_hashtag hashtag;
  match is_hashtag with
  | True =>
    verdad := tt
  | False =>
  end
end

procedure VerifyTweet(verify_info: VerifyInfo)
  match verify_info with
  | VerifyInfo twitter_id recipient_address tweet_id hashtags =>
    already_verified <- exists verified_tweets[tweet_id];
    match already_verified with
    | False =>
      last_claim <- last_claims[twitter_id];
      current_block <- & BLOCKNUMBER;
      not_next_day_yet =
        match last_claim with
        | Some last_claim_block =>
          let next_day_block = builtin badd last_claim_block blocks_per_day in
            builtin blt current_block next_day_block
        | None => False
        end;
      match not_next_day_yet with
      | False =>
        (* Reset verdad *)
        verdad := ff;
        forall hashtags ValidateTweet;
        output_verdad <- verdad;
        match output_verdad with
        | True =>
          verified_tweets[tweet_id] := twitter_id;
          last_claims[twitter_id] := current_block;
          e = {
            _eventname : "VerifyTweetSuccessful";
            twitter_id: twitter_id;
            recipient: recipient_address;
            tweet_id: tweet_id;
            reward: zils_per_tweet
          };
          event e;
          msg = {_tag: ""; _recipient: recipient_address; _amount: zils_per_tweet};
          msgs = one_msg msg;
          send msgs
        | False =>
          err = CodeTweetNotValid;
          EmitError err
        | True =>
          withdrawal <- last_withdrawal[twitter_id];
          current_block <- & BLOCKNUMBER;
          not_next_day_yet =
            match withdrawal with
            | Some last_withdraw_block =>
              let next_day_block = builtin badd last_withdraw_block blocks_per_day in
              builtin blt current_block next_day_block
            | None =>
              False
            end;
          match not_next_day_yet with
          | True =>
            err = CodeTweetWithinDay;
            EmitError err
          | False =>
            verified_tweets[tweet_id] := recipient_address;
            last_withdrawal[twitter_id] := current_block;
            e = {
              _eventname : "VerifyTweetSuccessful";
              sender: _sender;
              recipient: recipient_address;
              twitter_id: twitter_id;
              tweet_id: tweet_id;
              reward_amount: zils_per_tweet
            };
            event e;
            msg = { 
              _tag: "";
              _recipient: recipient_address;
              _amount: zils_per_tweet 
            };
            msgs = one_msg msg;
            send msgs
          end
        end
      | True =>
        err = CodeTweetWithinDay;
        EmitError err
      end
    | True =>
      err = CodeTweetAlreadyExists;
      EmitError err
    end
  end
end

transition Deposit()
  IsOwner;
  accept;
  e = {_eventname : "DepositSuccessful"; sender: _sender; deposit_amount: _amount};
  event e
end

transition ConfigureAdmins(admin_addresses: List ByStr20)
  IsOwner;
  forall admin_addresses ConfigureAdmin
end

transition VerifyTweets(verify_infos: List VerifyInfo)
  IsAdmin;
  forall verify_infos VerifyTweet
end

transition ReturnFund ()
  IsOwner;
  bal <- _balance;
  is_owner = builtin eq owner _sender;
  match is_owner with
  | True =>
    e = {
      _eventname : "ReturnFundSuccessful";
      returned_amount: bal
    };
    event e;
    msg = {
      _tag       : "";
      _recipient : owner;
      _amount    : bal
    };
    msgs = one_msg msg;
    send msgs
  | False =>
    err = CodeNotAuthorized;
    EmitError err
  end
end
