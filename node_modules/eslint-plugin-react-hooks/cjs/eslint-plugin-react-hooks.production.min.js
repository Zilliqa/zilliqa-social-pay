/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function T(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&T(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function ba(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ca(a,e){return a.name===e||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===e}function da(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"forwardRef"))}
function ea(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"memo"))}function fa(a){for(;a;){var e=ha(a);if(e&&(ba(e)||T(e))||da(a)||ea(a))return!0;a=a.parent}return!1}
function ha(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function V(a){function e(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function d(a,c){c=c.split(".");var m=!0,k=!1,d=void 0;try{for(var h=c[Symbol.iterator](),p;!(m=(p=h.next()).done);m=!0){var z=p.value,g=a.children.get(z);g||(g=e(),a.children.set(z,g));a=g}}catch(E){k=!0,d=E}finally{try{m||null==h.return||h.return()}finally{if(k)throw d;}}return a}function h(a,c,e){c=c.split(".");var m=!0,k=!1,d=void 0;try{for(var h=c[Symbol.iterator](),g;!(m=(g=h.next()).done);m=
!0){var z=a.children.get(g.value);if(!z)break;e(z);a=z}}catch(E){k=!0,d=E}finally{try{m||null==h.return||h.return()}finally{if(k)throw d;}}}function c(a,e,k,h){a.children.forEach(function(a,m){var d=h(m);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&k.add(d):a.isRequired?e.add(d):c(a,e,k,function(a){return d+"."+a})})}var z=a.dependencies,l=a.declaredDependencies,v=a.optionalDependencies,k=a.externalDependencies,C=a.isEffect,F=e();z.forEach(function(a,c){d(F,c).isRequired=!0;h(F,c,function(a){a.hasRequiredNodesBelow=
!0})});l.forEach(function(a){d(F,a.key).isSatisfiedRecursively=!0});v.forEach(function(a){d(F,a).isSatisfiedRecursively=!0});a=new Set;var g=new Set;c(F,a,g,function(a){return a});var u=[],x=new Set,A=new Set;l.forEach(function(a){a=a.key;g.has(a)?-1===u.indexOf(a)?u.push(a):A.add(a):!C||a.endsWith(".current")||k.has(a)?x.add(a):-1===u.indexOf(a)&&u.push(a)});a.forEach(function(a){u.push(a)});return{suggestedDependencies:u,unnecessaryDependencies:x,duplicateDependencies:A,missingDependencies:a}}
function ia(a){var e=a.declaredDependenciesNode,d=a.componentScope,h=a.scope;return a.declaredDependencies.map(function(a){a=d.set.get(a.key);if(null==a)return null;var c=a.defs[0];return null==c?null:"Variable"===c.type&&"VariableDeclarator"===c.node.type&&null!=c.node.init&&("ArrowFunctionExpression"===c.node.init.type||"FunctionExpression"===c.node.init.type)||"FunctionName"===c.type&&"FunctionDeclaration"===c.node.type?a:null}).filter(Boolean).map(function(a){var c=a.defs[0];a:{for(var d=!1,v=
0;v<a.references.length;v++){var k=a.references[v];if(k.writeExpr)if(d){a=!0;break a}else{d=!0;continue}for(var C=k.from;C!==h&&null!=C;)C=C.upper;if(C!==h&&!ja(e,k.identifier)){a=!0;break a}}a=!1}return{fn:c,suggestUseCallback:a}})}function ka(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:ka(a.parent)}
function X(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var e=X(a.object);a=X(a.property);return e+"."+a}function ma(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function na(a,e){var d=ma(a);if("Identifier"!==d.type)return null;switch(d.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(d===a&&e&&e.additionalHooks){try{var h=X(d)}catch(c){if(/Unsupported node type/.test(c.message))return 0;throw c;}return e.additionalHooks.test(h)?0:-1}return-1}}
function Y(a,e){for(var d=[a],h=null;d.length;){h=d.shift();if("Identifier"===h.type&&h.name===e.name&&h.range[0]===e.range[0]&&h.range[1]===e.range[1])return h;if(ja(h,e)){a=0;for(var c=Object.entries(h);a<c.length;a++){var z=c[a],l=z[1];"parent"!==z[0]&&(oa(l)?(l.parent=h,d.push(l)):Array.isArray(l)&&l.forEach(function(a){oa(a)&&(a.parent=h,d.push(a))}))}}}return null}
function pa(a){for(var e="",d=0;d<a.length;d++)e+=a[d],0===d&&2===a.length?e+=" and ":d===a.length-2&&2<a.length?e+=", and ":d<a.length-1&&(e+=", ");return e}function oa(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ja(a,e){return a.range[0]<=e.range[0]&&a.range[1]>=e.range[1]}
module.exports={rules:{"rules-of-hooks":{create:function(a){var e=[],d=[];return{onCodePathSegmentStart:function(a){return d.push(a)},onCodePathSegmentEnd:function(){return d.pop()},onCodePathStart:function(){return e.push(new Map)},onCodePathEnd:function(d,c){function h(a){var c=h.cache,b=c.get(a.id);if(null===b){if(!C.has(a.id)){C.add(a.id);c=!0;b=!1;var n=void 0;try{for(var f=a.prevSegments[Symbol.iterator](),B;!(c=(B=f.next()).done);c=!0)h(B.value)}catch(L){b=!0,n=L}finally{try{c||null==f.return||
f.return()}finally{if(b)throw n;}}}return 0}if(void 0!==b)return b;c.set(a.id,null);if(d.thrownSegments.includes(a))b=0;else if(0===a.prevSegments.length)b=1;else{b=0;f=!0;B=!1;var e=void 0;try{n=a.prevSegments[Symbol.iterator]();for(var k;!(f=(k=n.next()).done);f=!0)b+=h(k.value)}catch(L){B=!0,e=L}finally{try{f||null==n.return||n.return()}finally{if(B)throw e;}}}a.reachable&&0===b?c.delete(a.id):c.set(a.id,b);return b}function l(a){var c=l.cache,b=c.get(a.id);if(null===b){if(!C.has(a.id)){C.add(a.id);
c=!0;b=!1;var n=void 0;try{for(var f=a.nextSegments[Symbol.iterator](),B;!(c=(B=f.next()).done);c=!0)l(B.value)}catch(L){b=!0,n=L}finally{try{c||null==f.return||f.return()}finally{if(b)throw n;}}}return 0}if(void 0!==b)return b;c.set(a.id,null);if(d.thrownSegments.includes(a))b=0;else if(0===a.nextSegments.length)b=1;else{b=0;f=!0;B=!1;var e=void 0;try{n=a.nextSegments[Symbol.iterator]();for(var k;!(f=(k=n.next()).done);f=!0)b+=l(k.value)}catch(L){B=!0,e=L}finally{try{f||null==n.return||n.return()}finally{if(B)throw e;
}}}c.set(a.id,b);return b}function v(a){var c=v.cache,b=c.get(a.id);if(null===b)return Infinity;if(void 0!==b)return b;c.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var n=!0,f=!1,B=void 0;try{for(var e=a.prevSegments[Symbol.iterator](),d;!(n=(d=e.next()).done);n=!0){var k=v(d.value);k<b&&(b=k)}}catch(qa){f=!0,B=qa}finally{try{n||null==e.return||e.return()}finally{if(f)throw B;}}b+=1}c.set(a.id,b);return b}var k=e.pop();if(0!==k.size){var C=new Set;h.cache=new Map;l.cache=new Map;
v.cache=new Map;var F=l(d.initialSegment),g=ha(c),u=fa(c),x=g?ba(g)||T(g):da(c)||ea(c),A=Infinity,m=!0,p=!1,I=void 0;try{for(var t=d.finalSegments[Symbol.iterator](),K;!(m=(K=t.next()).done);m=!0){var W=K.value;if(W.reachable){var S=v(W);S<A&&(A=S)}}}catch(G){p=!0,I=G}finally{try{m||null==t.return||t.return()}finally{if(p)throw I;}}m=!0;p=!1;I=void 0;try{for(var y=k[Symbol.iterator](),P;!(m=(P=y.next()).done);m=!0){var E=P.value,D=E[0],M=E[1];if(D.reachable){var J=0===D.nextSegments.length?A<=v(D):
A<v(D),Q=h(D)*l(D),H=C.has(D.id);k=!0;t=!1;K=void 0;try{for(var w=M[Symbol.iterator](),N;!(k=(N=w.next()).done);k=!0){var r=N.value;H&&a.report({node:r,message:'React Hook "'+a.getSource(r)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(x){if(!H&&Q!==F){var U='React Hook "'+a.getSource(r)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(J?" Did you accidentally call a React Hook after an early return?":"");a.report({node:r,message:U})}}else if(!c.parent||"MethodDefinition"!==c.parent.type&&"ClassProperty"!==c.parent.type||c.parent.value!==c)if(g){var O='React Hook "'+a.getSource(r)+'" is called in function "'+(a.getSource(g)+'" that is neither a React function component nor a custom React Hook function.');a.report({node:r,message:O})}else if("Program"===c.type){var R='React Hook "'+a.getSource(r)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:r,message:R})}else if(u){var q='React Hook "'+a.getSource(r)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:r,message:q})}}}catch(G){t=!0,K=G}finally{try{k||null==w.return||w.return()}finally{if(t)throw K;}}}}}catch(G){p=!0,I=G}finally{try{m||null==y.return||y.return()}finally{if(p)throw I;}}}},CallExpression:function(a){if(T(a.callee)){var c=e[e.length-1],h=d[d.length-1],l=c.get(h);l||
(l=[],c.set(h,l));l.push(a.callee)}}}}},"exhaustive-deps":{meta:{schema:[{type:"object",additionalProperties:!1,properties:{additionalHooks:{type:"string"}}}]},create:function(a){function e(a,c){return function(e){if(c.has(e))return c.get(e);var d=a(e);c.set(e,d);return d}}function d(d){function k(a){var b=!0,f=!1,c=void 0;try{for(var e=a.references[Symbol.iterator](),h;!(b=(h=e.next()).done);b=!0){var g=h.value;if(g.resolved&&I.has(g.resolved.scope)){var m=Y(d,g.identifier),l=ka(m),p=X(l),r;if(r=
A&&"Identifier"===l.type&&"MemberExpression"===l.parent.type&&!l.parent.computed&&"Identifier"===l.parent.property.type&&"current"===l.parent.property.name){for(var q=g.from,u=!1;q.block!==d;)"function"===q.type&&(u=null!=q.block.parent&&"ReturnStatement"===q.block.parent.type),q=q.upper;r=u}r&&S.set(p,{reference:g,dependencyNode:l});var t=g.resolved.defs[0];if(null!=t&&(null==t.node||t.node.init!==d.parent)&&"TypeParameter"!==t.type)if(y.has(p))y.get(p).references.push(g);else{var w=g.resolved,z=
K(w)||W(w);y.set(p,{isStatic:z,references:[g]})}}}}catch(aa){f=!0,c=aa}finally{try{b||null==e.return||e.return()}finally{if(f)throw c;}}b=!0;f=!1;c=void 0;try{for(var v=a.childScopes[Symbol.iterator](),x;!(b=(x=v.next()).done);b=!0)k(x.value)}catch(aa){f=!0,c=aa}finally{try{b||null==v.return||v.return()}finally{if(f)throw c;}}}function F(a,n,f,c){return 0===a.size?null:(1<a.size?"":n+" ")+f+" "+(1<a.size?"dependencies":"dependency")+": "+pa(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+
(". Either "+c+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}if(("FunctionExpression"===d.type||"ArrowFunctionExpression"===d.type)&&"CallExpression"===d.parent.type){var g=na(d.parent.callee,h);if(d.parent.arguments[g]===d){var u=d.parent.callee,x=ma(u).name,A=/Effect($|[^a-z])/g.test(x),m=d.parent.arguments[g+1];if(m||A){A&&d.async&&a.report({node:d,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});
var p=a.getScope(),I=new Set,t=null;for(g=p.upper;g;){I.add(g);if("function"===g.type)break;g=g.upper}if(g){t=g;var K=e(function(a){if(!Array.isArray(a.defs))return!1;var b=a.defs[0];if(null==b||"VariableDeclarator"!==b.node.type)return!1;var f=b.node.init;if(null==f)return!1;var d=b.node.parent;if(null==d&&(Y(t.block,b.node.id),d=b.node.parent,null==d))return!1;if("const"===d.kind&&"Literal"===f.type&&("string"===typeof f.value||"number"===typeof f.value||null===f.value))return!0;if("CallExpression"!==
f.type)return!1;f=f.callee;"MemberExpression"!==f.type||"React"!==f.object.name||null==f.property||f.computed||(f=f.property);if("Identifier"!==f.type)return!1;b=b.node.id;f=f.name;if("useRef"===f&&"Identifier"===b.type)return!0;if(("useState"===f||"useReducer"===f)&&"ArrayPattern"===b.type&&2===b.elements.length&&Array.isArray(a.identifiers)){if(b.elements[1]===a.identifiers[0]){if("useState"===f)for(a=a.references,f=0;f<a.length;f++)c.set(a[f].identifier,b.elements[0]);return!0}if(b.elements[0]===
a.identifiers[0]&&"useState"===f)for(a=a.references,b=0;b<a.length;b++)z.add(a[b].identifier)}return!1},l),W=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var b=a.node,f=t.childScopes;a=null;var c;for(c=0;c<f.length;c++){var d=f[c],e=d.block;if("FunctionDeclaration"===b.type&&e===b||"VariableDeclarator"===b.type&&e.parent===b){a=d;break}}if(null==a)return!1;for(c=0;c<a.through.length;c++)if(b=a.through[c],null!=b.resolved&&I.has(b.resolved.scope)&&
!K(b.resolved))return!1;return!0},v),S=new Map,y=new Map;k(p);S.forEach(function(b,c){var f=b.dependencyNode;b=b.reference.resolved.references;for(var d=!1,e=0;e<b.length;e++){var n=b[e].identifier.parent;if(null!=n&&"MemberExpression"===n.type&&!n.computed&&"Identifier"===n.property.type&&"current"===n.property.name&&"AssignmentExpression"===n.parent.type&&n.parent.left===n){d=!0;break}}d||a.report({node:f.parent.property,message:"The ref value '"+c+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+
(c+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var P=new Set,E=new Set;y.forEach(function(b,c){var f=b.references;b.isStatic&&E.add(c);f.forEach(function(b){b.writeExpr&&(b=b.writeExpr,P.has(c)||(P.add(c),a.report({node:b,message:"Assignments to the '"+c+"' variable from inside React Hook "+(a.getSource(u)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(u)+".")})))})});if(!(0<P.size))if(m){var D=[],M=new Set;"ArrayExpression"!==m.type?a.report({node:m,message:"React Hook "+a.getSource(u)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):m.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)a.report({node:b,message:"React Hook "+a.getSource(u)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var c=X(b)}catch(la){if(/Unsupported node type/.test(la.message)){"Literal"===b.type?y.has(b.value)?a.report({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):a.report({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):a.report({node:b,message:"React Hook "+a.getSource(u)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw la;}for(var f=b;"MemberExpression"===f.type;)f=f.object;var d=!t.through.some(function(a){return a.identifier===f});D.push({key:c,node:b});d||M.add(c)}});var J=V({dependencies:y,declaredDependencies:D,optionalDependencies:E,externalDependencies:M,isEffect:A}),Q=J.suggestedDependencies;g=J.unnecessaryDependencies;var H=J.missingDependencies;J=J.duplicateDependencies;if(0===J.size+H.size+g.size)ia({declaredDependencies:D,declaredDependenciesNode:m,componentScope:t,scope:p}).forEach(function(b){var c=
b.fn;b=b.suggestUseCallback;var f="The '"+c.name.name+"' function makes the dependencies of "+(x+" Hook (at line "+m.loc.start.line+") change on every render.");f=b?f+(" To fix this, wrap the '"+(c.name.name+"' definition into its own useCallback() Hook.")):f+(" Move it inside the "+x+" callback. Alternatively, wrap the '"+(c.name.name+"' definition into its own useCallback() Hook."));var d;b&&"Variable"===c.type&&(d=[{desc:"Wrap the '"+c.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(c.node.init,"useCallback("),a.insertTextAfter(c.node.init,")")]}}]);a.report({node:c.node,message:f,suggest:d})});else{!A&&0<H.size&&(Q=V({dependencies:y,declaredDependencies:[],optionalDependencies:E,externalDependencies:M,isEffect:A}).suggestedDependencies);(function(){if(0===D.length)return!0;var a=D.map(function(a){return a.key}),c=a.slice().sort();return a.join(",")===c.join(",")})()&&Q.sort();var w="";if(0<g.size){var N=null;Array.from(g.keys()).forEach(function(a){null===
N&&a.endsWith(".current")&&(N=a)});if(null!==N)w=" Mutable values like '"+N+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<M.size){var r=Array.from(M)[0];p.set.has(r)||(w=" Outer scope values like '"+r+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!w&&H.has("props")){p=y.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;r=!0;for(var U=0;U<p.length;U++){var O=Y(t.block,p[U].identifier);
if(!O){r=!1;break}O=O.parent;if(null==O){r=!1;break}if("MemberExpression"!==O.type){r=!1;break}}r&&(w=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(x+" call and refer to those specific props inside ")+(a.getSource(u)+"."))}if(!w&&0<H.size){var R=null;H.forEach(function(a){if(!R){var b=t.set.get(a),c=y.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,
e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){b=!0;break}b&&(R=a)}}});null!==R&&(w=" If '"+R+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!w&&0<H.size){var q=null;H.forEach(function(a){if(null===q)for(var b=y.get(a).references,d,e,g=0;g<b.length;g++){d=b[g].identifier;for(e=d.parent;null!=e&&e!==t.block;){if("CallExpression"===e.type){var h=
c.get(e.callee);if(null!=h){h.name===a?q={missingDep:a,setter:e.callee.name,form:"updater"}:z.has(d)?q={missingDep:a,setter:e.callee.name,form:"reducer"}:(d=b[g].resolved,null!=d&&(d=d.defs[0],null!=d&&"Parameter"===d.type&&(q={missingDep:a,setter:e.callee.name,form:"inlineReducer"})));break}}e=e.parent}if(null!==q)break}});if(null!==q)switch(q.form){case "reducer":w=" You can also replace multiple useState variables with useReducer if '"+(q.setter+"' needs the current value of '")+(q.missingDep+
"'.");break;case "inlineReducer":w=" If '"+q.setter+"' needs the current value of '"+(q.missingDep+"', you can also switch to useReducer instead of useState and read '")+(q.missingDep+"' in the reducer.");break;case "updater":w=" You can also do a functional update '"+q.setter+"("+q.missingDep.substring(0,1)+" => ...)' if you only need '"+q.missingDep+"' in the '"+(q.setter+"' call.");break;default:throw Error("Unknown case.");}}a.report({node:m,message:"React Hook "+a.getSource(u)+" has "+(F(H,"a",
"missing","include")||F(g,"an","unnecessary","exclude")||F(J,"a","duplicate","omit"))+w,suggest:[{desc:"Update the dependencies array to be: ["+Q.join(", ")+"]",fix:function(a){return a.replaceText(m,"["+Q.join(", ")+"]")}}]})}}else{var G=null;y.forEach(function(a,e){G||a.references.forEach(function(a){if(!G&&c.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===d&&(G=e)}})});if(G){var Z=V({dependencies:y,declaredDependencies:[],optionalDependencies:E,externalDependencies:new Set,
isEffect:!0}).suggestedDependencies;a.report({node:d.parent.callee,message:"React Hook "+x+" contains a call to '"+G+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+Z.join(", ")+("] as a second argument to the "+x+" Hook."),suggest:[{desc:"Add dependencies array: ["+Z.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,", ["+Z.join(", ")+"]")}}]})}}}}else"useMemo"!==x&&"useCallback"!==x||a.report({node:d.parent.callee,message:"React Hook "+
x+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}var h={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0},c=new WeakMap,z=new WeakSet,l=new WeakMap,v=new WeakMap;return{FunctionExpression:d,ArrowFunctionExpression:d}}}}};
